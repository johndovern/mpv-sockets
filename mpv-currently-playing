#!/bin/bash
# mpv-get-property wrapper that gets full path of currently playing song
# If there are multiple sockets, presents you with fzf to pick one
# Can also provide an alternate command as a sink, like:
# mpv-currently-playing cat
#
# Do mpv-currently-playing 2>/dev/null to ignore errors from mpv
# instances which are streaming media instead of playing a local path
#
# By default, this all items, even if they're paused.
# If you want to truly only list items which are currently playing,
# set the MPV_IS_PLAYING environment variable: MPV_IS_PLAYING=1 mpv-currently-playing cat

declare -a full_paths=()
for socket in $(mpv-active-sockets); do
	if SONG_PATH="$(mpv-get-property "$socket" 'path' 2>/dev/null)"; then
		# if the path doesnt correspond to its absolute path, or this doesnt exist, try prepending the working directory
		[[ -n "$SONG_PATH" && -e "$SONG_PATH" ]] || {
			SONG_PATH="$(mpv-get-property "$socket" 'working-directory')/${SONG_PATH}"
		}
		if [[ -e "$SONG_PATH" ]]; then
			if [[ -n "$MPV_IS_PLAYING" ]]; then
				IS_PAUSED="$(mpv-get-property "$socket" 'pause')"
				[[ "$IS_PAUSED" == "true" ]] && continue
			fi
			full_paths+=("$SONG_PATH")
		else
			echo "Error: ${SONG_PATH} doesn't exist" >&2
		fi
	fi
done

# switch on length of array (number of paths found)
case "${#full_paths[@]}" in
0)
	exit 1
	;;
1)
	echo "${full_paths[0]}"
	;;
*)
	(
		IFS=$'\n'
		echo "${full_paths[*]}"
	) | "${1:-fzf}" || exit $?
	;;
esac
